\documentclass[fontsize=11pt]{article}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=0.75in]{geometry}
\usepackage{hyperref}
\urlstyle{same}

\title{CSC111 Project 2 Proposal: \\ \textbf{“Destiny” - Find Your Next Soulmate Here}}
\author{Hsin Kuang (Joseph) Cheung \\ Tsz Kan Charlotte Wong \\ Yan Lam \\ Chun Yin Liang}
\date{\today}

\begin{document}
\maketitle

\section*{Introduction}

The University of Toronto is a community with a diverse student population, with lots of international students (University of Toronto, 2024).
As we enter early adulthood, the struggle between isolation and intimacy becomes significant.
Many students feel lonely and stressed when making new connections and managing their academic burden, especially those from abroad who experience homesickness.
\textbf{How can students in UofT meet new people and build a supportive circle beyond lectures with less effort?
This is a challenge that is faced by most of our group members since we are new to the city.}
\\
\\
To address this problem, we wanted to introduce a new application called \textbf{Destiny}.
It is designed to make socializing easier and more interesting, enriching students’ university lives.
This is not just another “dating app” but a platform where students can seek both friends and potential romantic partners. By offering a wide pool of potential matches, the application helps users connect effortlessly - whether you are looking for a study partner, a coffee companion, or even a date.
\\
\\
With a user-friendly interface, students can create profiles showcasing their interests, personality traits, and preferred connections.
The algorithm helps suggest matches based on shared hobbies and values, making it easier to meet like-minded people while reducing the insecurity of approaching someone out of fear of rejection. To ensure more compatible connections, the application provides a personalized environment where students can select their preferred qualities.
\\
\\
\textbf{By encouraging friendships and romantic bonds, we aim to create a welcoming platform where students can develop personally, and build meaningful, enduring relationships.}
Four of our group members are international students themselves, and thus, we understand firsthand the importance of a strong supportive network, either as friends or something more, in enhancing mental health and student engagement throughout university life.

This application is not yet fully completed, but rather more like a prototype, since we lack user base. 
With some modification to the program code to make it real-time, we can make the app a real application. 

\section*{Dataset}
Ideally, we should collect data from current UofT students to build a realistic database of actual users.
However, due to time constraints and privacy concerns, we chose to generate a synthetic dataset of 200 users for this project.
These users have different attributes and preferences, and we used the Faker Python library to generate these data.
The data generation is done with \texttt{generate\_users\_with\_class()} function in \texttt{user\_network.py}, which creates a list of \texttt{User} objects.
We also added the four of us into this dataset, so we have a total of 204 users.

\section*{Computational Overview}


\\
\\
\subsection*{Tree}
We are implementing a Binary Tree to match users to generate a list of matches based on the users’ preference for attributes.
Before using the app, each user is asked to select a dating goal: meeting new friends, situationship, short-term relationship, or long-term relationship.
Then, the user is asked to enter their answer for each attribute, and is stored in our dataset.
\\
\\
To build the preference tree, we use \texttt{data\_wrangling} function to convert users' information and the matching status 
of their attributes into a CSV file named \texttt{data.csv}. We first call the \texttt{add\_priority} function to allow users to order their characteristics 
by preference, storing the result in a list called \texttt{heading}. Then, we filter the dataset to create a \texttt{potential\_users} list, containing only 
those users whose dating goals match that of the current user. In order to build the CSV file, we initialize a dictionary with keys corresponding to the column 
headers in the file. By default, the dictionary contains a \texttt{name} key, to which we add the names of the users from \texttt{potential\_users}. The other keys in 
the dictionary correspond to each attribute in \texttt{heading}, and their values are either 1 (indicating a match) or 0 (indicating no match), based on comparing the 
attribute value of each potential user with those of the current user. Lastly, a pandas \texttt{DataFrame} is created from the dictionary and exported to the CSV file.
\\
\\
% To do: build_preference_tree function + reordering the paragraph
The \texttt{insert\_sequence} function inserts a sequence of items into a binary tree, where the first item, either 0 or 1, determines whether to recurse into the left or right subtree. 
Each subsequent item in the sequence continues branching deeper into the tree. The final item, which represents the user’s name, is stored in a list at the corresponding leaf node.
\\
\\
\texttt{run\_preference\_tree} is a recursive function that returns a list of ranked recommended users by traversing the binary tree in the preference-based manner, 
which prioritizes the left subtree first (closest match) before processing the right subtree (lower match). The base case occurs when \texttt{self.\_root} is a list, 
which stores user names (indicating a leaf node). The function is then able to extend the \texttt{recommendation\_list} with the user names, returns, and stops recursion. 
The recursive step happens when the current node is not a leaf. The function extends the \texttt{recommendation\_list} by recursively traversing the left subtree first (higher preference) then 
the right subtree (lower preference).
\end{itemize}
Each user ranks their priorities for different attributes (e.g., common interests, program of study, personality traits).
\\
\\
According to their priorities, a binary decision tree is built using these ranked attributes as decision nodes.
For example, if a user prioritizes hobbies the most, then hobbies will be at the first level of the tree.
Then, the most important attribute is at the root of the tree, and the least important attribute is at the bottom of the tree.
The root of the tree is “ ”, and each node could be either: \texttt{Yes} (match), or \texttt{No} (mismatch), except the leaves where nodes represent users.
The program will systematically traverse through the tree (taking the \texttt{Yes} path).
After reaching a leaf, the user will be added to \texttt{result}, which is a list of potential matches in order.
If there is more than one leaf with common attributes, start from the leftmost node.
(For example, if user A and user B share the same attributes, user A will be added to \texttt{result} first.)
After the first all-\texttt{Yes} path, the second priority would be given to the path where the last level is \texttt{No}
(which means the least important attribute is mismatched, but other higher-priority attributes are matched).
The final full list \texttt{result}, including all users, is generated and ordered according to ranking based on compatibility.
\\
\\
The user will be first shown with the first matching user in the \texttt{result} \textt{list} (i.e., \texttt{result[0]}).
If the user “refreshes” the page, then the next matching user (\texttt{result[1]}) will be suggested, and so on.
If the user successfully matches with another user, they will be stored in \texttt{romantic\_matches} and/or \texttt{friend\_matches},
which are lists of sets, with the data type of \texttt{list[set[User]]}.
Each set contains two users, which are instances of the \texttt{User} class.
Also, \texttt{user\_list} is a list of all users in the system, with the data type of \texttt{list[User]}.
\\
\\
\subsection*{Graph}
After users are matched through the system, we used network graphs to visualize the connections between all users.
There are two graphs, one displaying social connections (social graph) and the other displaying romantic connections (dating graph).
In these graphs, each node represents one user, and each edge represents a connection between two users.
In the social grpah, the size of each node is directly proportional to its degree, i.e., a user with more friends will appear as a larger node in the graph.
In the dating graph, all nodes are the same size, since the number of romantic partners is limited to one.
\\
\\
These two graphs are created using the function \texttt{create\_app()} in \texttt{graph.py}.
Three lists are passed into the function, which are \texttt{user\_list}, \texttt{user\_looking\_for\_friends}, and \texttt{user\_looking\_for\_love}.
from \texttt{user\_list} (for generating all the nodes on the graphs),
\texttt{romantic\_matches}, and \texttt{friend\_matches} (for generating the edges, and showing their connections).
We will generate these interactive graphs using plotly, an interactive graphing Python library (Plotly, 2025).
Then, as the developers of the application, we can zoom in and out of the graph, and view the detailed information of different users in our system.
\\
\\
This project contains three different Python files: \texttt{user\_network.py}, \texttt{graph.py}, and \texttt{ui.py}. Below is a breakdown of the main components and responsibilities of each.

\section*{File: \texttt{user\_network.py}}

This file contains the core logic of the user system. Important classes and functions are defined here.

\subsection*{Classes}

\subsubsection*{User: Represents a user in the dating app.}

\paragraph{Instance Attributes}
\begin{itemize}
    \item \texttt{name}: the name of the user.
    \item \texttt{age}: the age of the user.
    \item \texttt{gender}: the gender of the user.
    \item \texttt{pronouns}: the pronouns of the user.
    \item \texttt{dating\_goal}: the user's dating goal. Options include: \\
    ``Meeting new friends'', ``Short-term relationship'', ``Long-term relationship'', or ``Situationship''.
    \item \texttt{characteristics}: a \texttt{Characteristic} object representing user preferences and traits.
    \item \texttt{interested\_friend}: a list of users the user is interested in.
    \item \texttt{romantic\_current}: the user's current romantic partner.
    \item \texttt{romantic\_ex}: list of user's ex-romantic partners.
    \item \texttt{social\_current}: list of the user's current friends.
    \item \texttt{social\_ex}: list of users who were unfriended.
    \item \texttt{romantic\_degree}: number of romantic relationships (0 or 1).
    \item \texttt{social\_degree}: number of current friends.
\end{itemize}

\subsubsection*{Characteristic: Represents user characteristics that influence their preferences.}


\paragraph{Instance Attributes}
\begin{itemize}
    \item \texttt{ethnicity}: The user's ethnicity.
    \item \texttt{interests}: List of hobbies or interests.
    \item \texttt{mbti}: Myers-Briggs personality type (e.g., INFP, ESTJ).
    \item \texttt{communication\_type}: Preferred communication style (e.g., text, call, in-person).
    \item \texttt{political\_interests}: Political views or level of engagement.
    \item \texttt{religion}: Religious belief.
    \item \texttt{major}: Academic major (e.g., Computer Science, Psychology).
    \item \texttt{year}: Academic year (e.g., First Year, Junior, Senior).
    \item \texttt{language}: Primary spoken language.
    \item \texttt{likes\_pets}: Whether the user likes pets.
    \item \texttt{likes\_outdoor\_activities}: Whether the user enjoys outdoor activities.
    \item \texttt{enjoys\_watching\_movies}: Whether the user enjoys watching movies or shows.
\end{itemize}

\subsection*{Functions}

\subsubsection*{\texttt{generate\_users\_with\_class}}
- Simulates user generation.

\paragraph{Arguments}
\begin{itemize}
    \item \texttt{list\_size}: number of users to generate.
    \item \texttt{seed}: seed for random generation.
\end{itemize}

\subsubsection*{\texttt{add\_fixed\_users}}
- Adds predefined users (e.g., project creators) to the user list. This function mutates the list passed in.

\subsubsection*{\texttt{add\_user}}
- Interactive function that prompts for user input (like a registration form) and appends a new \texttt{User} object to the user list.

\\


\begin{itemize}
\item We use a tree structure to match users based on their preferred attributes. Attributes are ranked as decision nodes according to user priorities (e.g., if a user values hobbies the most, hobbies will be the first level of the tree). Users who meet a given attribute are assigned a 1, while those who do not are assigned a 0. As a result, different users follow different branches, and a recommendation list is generated by prioritizing those who fulfill the highest number of a user's preferred attributes.
\\
\item We build the preference tree using the \texttt{data\_wrangling} function by converting users' information and the matching status of their attributes into a CSV file named \texttt{data.csv}. We first call the \texttt{add\_priority} function to allow users to order their characteristics by preference, storing the result in a list called \texttt{heading}. Then, we filter the dataset to create a \texttt{potential\_users} list, containing only those users whose dating goals match that of the current user. In order to build the CSV file, we initialize a dictionary with keys corresponding to the column headers in the file. By default, the dictionary contains a \texttt{name} key, to which we add the names of the users from \texttt{potential\_users}. The other keys in the dictionary correspond to each attribute in \texttt{heading}, and their values are either 1 (indicating a match) or 0 (indicating no match), based on comparing the attribute value of each potential user with those of the current user. Lastly, a pandas \texttt{DataFrame} is created from the dictionary and exported to the CSV file.
\\
\item \texttt{insert\_sequence}: the function inserts a sequence of items into a binary tree, where the first item, either 0 or 1, determines whether to recurse into the left or right subtree. Each subsequent item in the sequence continues branching deeper into the tree. The final item, which represents the user’s name, is stored in a list at the corresponding leaf node.


\item \textbf{\texttt{build\_preference\_tree}}:  
The preference tree is generated by processing the CSV file, which has the format:  

\begin{quote}
\texttt{[name, ethnicity, interests, mbti, communication\_type,} \\
\texttt{political\_interests, religion, major, year, language,} \\
\texttt{likes\_pets, likes\_outdoor\_activities, enjoys\_watching\_movies]}
\end{quote}

with indicators 0 and 1 (*the order of the attributes changes based on the \texttt{data\_wrangling} function*).  

As the CSV function processes each row, \texttt{match} is created as a list containing the preference indicators, with the user's name appended at the end. This list is then passed as an argument to \texttt{insert\_sequence}, which constructs the tree accordingly. 
\\

\item \texttt{run\_preference\_tree} is a recursive function that returns a list of ranked recommended users by traversing the binary tree in the preference-based manner, which prioritizes the left subtree first (closest match) before processing the right subtree (lower match). The base case occurs when \texttt{self.\_root} is a list, which stores user names (indicating a leaf node). The function is then able to extend the \texttt{recommendation\_list} with the user names, returns, and stops recursion. The recursive step happens when the current node is not a leaf. The function extends the \texttt{recommendation\_list} by recursively traversing the left subtree first (higher preference) then the right subtree (lower preference).
\end{itemize}
\\

\\
\\

\\
\section*{Instructions for running the program}
Sample demonstration: Run main.py. The app with the UI should then pop up. Enter any name, say, 'Peter' to continue. Then fill in the form to complete a registration. Choose "Meeting new friends" for the Dating Goal. This tells the system that you are looking for friends more than looking for relationships. Rank the features you value the most using at the bottom of the page. Click "Create Profile".

Then click "Find Matches". Here, you can either choose Match or Pass. After you are done matching, press Exit. You will be re-directed back to the main menu.

Now, you can create another profile for another person, say, 'Mary'. But this time, for "Dating Goal", choose the three options other than "Meeting New Friends", for example, "Long-term relationship". Click "Create Profile". Instead of matching friends, you will be brought to a page that helps you match with someone who is also looking for a relationship. After you successfully match a romantic partner, you can press "Return to Home".

Then, this time input "admin" as the name. This would log you into the admin console. For debugging purposes, you can "Print User List to Console". Press "View Network Graph" to view the visualization of the connections of the users in the application. Supposedly, a local web application would pop up in your default browser.

There are two connection maps: Social connections (friends) and Romantic connections (relationships). You can navigate the maps freely to see the connections between users. Try out the searching function by inputting "Peter" in the search box. If a user is found, it will locate that user node in the graph and highlighting his/her connection with red. The function also shows how many connections that person has.


\\
\paragraph{Changes to the project plan}
(tree part): Initially, we implemented the tree using the basic <self.\_root> and <self.\_subtree> structure to align with the format of Exercise 2's animal tree. However, we found that using a binary tree with self.\_root, self.\_left, and self.\_right was more suitable for our recommendation system. This approach is particularly effective because all the 1s in the tree, representing users most relevant to the target user, are positioned along the leftmost branch. By using a binary tree, we can simplify the process of generating a recommendation list by recursively traversing only the leftmost branch.


\\
\paragraph{Discussion}
\ Does the product meet our original goal?
At this stage, this application does not really help Uoft Students to match their soulmates, since the app right now has no user base and is more like a prototype.
This is mainly due to time and ability constraints -- we do not have the ability to build a real working app with an interactive UI, since it is out-of-the-scope for our current CSC110/111 curriculum. Yet, we wanted to make the application as real as possible. That is why we did seek help from AI for helping us on unfamilar libraries by generating code, mainly on the UI (ui.py) and (graph.py). This is mainly because we do not want to spend most of the time on understanding how to use a new library, but instead we want to focus on building our own matching algorithms, graph data structures and data generating functions, which is closer to the aim of our course project.
Although the application is not really a published, usable app, we have built a project that can easily be transformed into a real-time working application. The prototype itself demonstrates the potential of the app and how it leverages tree/graph knowledge we learnt in class for creating this matching algorithm based on user features. The tree structure sets priorities at different levels, enabling the creation of a customized tree and a corresponding recommendation list. The graph effectively visualizes connections between users through edges, allowing us, as editors, to review potential relationships. 
This successfully fulfills our goal of developing a connection-based application.

\subsection{What are some limitations?} 
\ There are quite a few limitations we encountered when making our project. 
\ For example, originally we planned to implement a function that records the past romantic relationships and friendships of all the users. However, it would also imply that we have to generate users with broken friendships and relationships, which can be a bit complicated. We also discussed that this function is not that important since the app shouldn't really be recording past relationships of people, as we mainly just want to help users to know more people. In some sense, recording a person's ex feels like violating their own privacy rights, and such data isn't really needed.  
\ Another limiation would be our use of AI. As mentioned above, we did seek the help of AI to generate code for out-of-scope libraries and rarely used functions due to time constraints. 
\ 

\section*{References}

Plotly. (2025). \textit{Plotly}.
\url{https://plotly.com/python/}
\\
University of Toronto. (2024). \textit{Quick facts}.
\url{https://www.utoronto.ca/about-u-of-t/quick-facts}


% NOTE: LaTeX does have a built-in way of generating references automatically,
% but it's a bit tricky to use so we STRONGLY recommend writing your references
% manually, using a standard academic format like APA or MLA.
% (E.g., https://owl.purdue.edu/owl/research_and_citation/apa_style/apa_formatting_and_style_guide/general_format.html)

\end{document}