\documentclass[fontsize=11pt]{article}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=0.75in]{geometry}
\usepackage{hyperref}
\urlstyle{same}

\title{CSC111 Project 2 Proposal: \\ \textbf{“Destiny” - Find Your Next Soulmate Here}}
\author{Hsin Kuang (Joseph) Cheung \\ Tsz Kan Charlotte Wong \\ Yan Lam \\ Chun Yin Liang}
\date{\today}

\begin{document}
\maketitle

\section*{Problem Description and Research Question}

The University of Toronto is a community with a diverse student population, with lots of international students (University of Toronto, 2024).
As we enter early adulthood, the struggle between isolation and intimacy becomes significant.
Many students feel lonely and stressed when making new connections and managing their academic burden, especially those from abroad who experience homesickness.
\textbf{How can students in UofT meet new people and build a supportive circle beyond lectures with less effort?
This is a challenge that is faced by most of our group members since we are new to the city.}
\\
\\
To address this problem, we wanted to introduce a new application called \textbf{Destiny}.
It is designed to make socializing easier and more interesting, enriching students’ university lives.
This is not just another “dating app” but a platform where students can seek both friends and potential romantic partners. By offering a wide pool of potential matches, the application helps users connect effortlessly - whether you are looking for a study partner, a coffee companion, or even a date.
\\
\\
With a user-friendly interface, students can create profiles showcasing their interests, personality traits, and preferred connections.
The algorithm helps suggest matches based on shared hobbies and values, making it easier to meet like-minded people while reducing the insecurity of approaching someone out of fear of rejection. To ensure more compatible connections, the application provides a personalized environment where students can select their preferred qualities.
\\
\\
\textbf{By encouraging friendships and romantic bonds, we aim to create a welcoming platform where students can develop personally, and build meaningful, enduring relationships.}
Four of our group members are international students themselves, and thus, we understand firsthand the importance of a strong supportive network, either as friends or something more, in enhancing mental health and student engagement throughout university life.


\section*{Computational Plan}

Ideally, we should collect data from current UofT students to build a realistic database of actual users.
However, due to time constraints and privacy concerns, we will generate a synthetic dataset of 200 users for this project.
These users will have different attributes and preferences, and we will use the Faker Python library for generating data.
\\
\\
We are implementing a Binary Tree to match users to generate a list of matches based on the users’ preference for attributes.
Before using the app, each user is asked to choose whether they are looking for: friends, potential romantic partners, or both.
Two trees can be generated based on the user’s answer: one for matching friends, and one for matching potential romantic partners.
Then, the user is asked to enter their answer for each attribute.
Each user ranks their priorities for different attributes (e.g., common interests, program of study, personality traits).
\\
\\
According to their priorities, a binary decision tree is built using these ranked attributes as decision nodes.
For example, if a user prioritizes hobbies the most, then hobbies will be at the first level of the tree.
Then, the most important attribute is at the root of the tree, and the least important attribute is at the bottom of the tree.
The root of the tree is “ ”, and each node could be either: \texttt{Yes} (match), or \texttt{No} (mismatch), except the leaves where nodes represent users.
The program will systematically traverse through the tree (taking the \texttt{Yes} path).
After reaching a leaf, the user will be added to \texttt{result}, which is a list of potential matches in order.
If there is more than one leaf with common attributes, start from the leftmost node.
(For example, if user A and user B share the same attributes, user A will be added to \texttt{result} first.)
After the first all-\texttt{Yes} path, the second priority would be given to the path where the last level is \texttt{No}
(which means the least important attribute is mismatched, but other higher-priority attributes are matched).
The final full list \texttt{result}, including all users, is generated and ordered according to ranking based on compatibility.
\\
\\
We use a tree structure to match users based on their preferred attributes. Attributes are ranked as decision nodes according to user priorities (e.g., if a user values hobbies the most, hobbies will be the first level of the tree). Users who meet a given attribute are assigned a 1, while those who do not are assigned a 0. As a result, different users follow different branches, and a recommendation list is generated by prioritizing those who fulfill the highest number of a user's preferred attributes.
\\
The user will be first shown with the first matching user in the \texttt{result} \textt{list} (i.e., \texttt{result[0]}).
If the user “refreshes” the page, then the next matching user (\texttt{result[1]}) will be suggested, and so on.
If the user successfully matches with another user, they will be stored in \texttt{romantic\_matches} and/or \texttt{friend\_matches},
which are lists of sets, with the data type of \texttt{list[set[User]]}.
Each set contains two users, which are instances of the \texttt{User} class.
Also, \texttt{user\_list} is a list of all users in the system, with the data type of \texttt{list[User]}.
\\
\\
After users are matched through the system, they can be represented as a graph.
Network graphs will be used to visualize the connections between all users.
There will be two graphs, one targeted at people looking for romantic relationships and one for friendships.
Each node represents one user, and each edge represents a match between two users.
The size of each node is directly proportional to its degree, i.e., a user with more friends will appear as a larger node in the graph.
To distinguish between current and past relationships, the edges for current couples and friends will be in red, while the edges for ex-couples and ex-friends will be in blue.
\\
\\
These two network graphs are created from \texttt{user\_list} (for generating all the nodes on the graphs),
\texttt{romantic\_matches}, and \texttt{friend\_matches} (for generating the edges, and showing their connections).
We will generate these interactive graphs using plotly, an interactive graphing Python library (Plotly, 2025).
Then, as the developers of the application, we can zoom in and out of the graph, and view the detailed information of different users in our system.


This project contains three different Python files: \texttt{user\_network.py}, \texttt{graph.py}, and \texttt{ui.py}. Below is a breakdown of the main components and responsibilities of each.

\section*{File: \texttt{user\_network.py}}

This file contains the core logic of the user system. Important classes and functions are defined here.

\subsection*{Classes}

\subsubsection*{User: Represents a user in the dating app.}

\paragraph{Instance Attributes}
\begin{itemize}
    \item \texttt{name}: the name of the user.
    \item \texttt{age}: the age of the user.
    \item \texttt{gender}: the gender of the user.
    \item \texttt{pronouns}: the pronouns of the user.
    \item \texttt{dating\_goal}: the user's dating goal. Options include: \\
    ``Meeting new friends'', ``Short-term relationship'', ``Long-term relationship'', or ``Situationship''.
    \item \texttt{characteristics}: a \texttt{Characteristic} object representing user preferences and traits.
    \item \texttt{interested\_friend}: a list of users the user is interested in.
    \item \texttt{romantic\_current}: the user's current romantic partner.
    \item \texttt{romantic\_ex}: list of user's ex-romantic partners.
    \item \texttt{social\_current}: list of the user's current friends.
    \item \texttt{social\_ex}: list of users who were unfriended.
    \item \texttt{romantic\_degree}: number of romantic relationships (0 or 1).
    \item \texttt{social\_degree}: number of current friends.
\end{itemize}

\subsubsection*{Characteristic: Represents user characteristics that influence their preferences.}


\paragraph{Instance Attributes}
\begin{itemize}
    \item \texttt{ethnicity}: The user's ethnicity.
    \item \texttt{interests}: List of hobbies or interests.
    \item \texttt{mbti}: Myers-Briggs personality type (e.g., INFP, ESTJ).
    \item \texttt{communication\_type}: Preferred communication style (e.g., text, call, in-person).
    \item \texttt{political\_interests}: Political views or level of engagement.
    \item \texttt{religion}: Religious belief.
    \item \texttt{major}: Academic major (e.g., Computer Science, Psychology).
    \item \texttt{year}: Academic year (e.g., First Year, Junior, Senior).
    \item \texttt{language}: Primary spoken language.
    \item \texttt{likes\_pets}: Whether the user likes pets.
    \item \texttt{likes\_outdoor\_activities}: Whether the user enjoys outdoor activities.
    \item \texttt{enjoys\_watching\_movies}: Whether the user enjoys watching movies or shows.
\end{itemize}

\subsection*{Functions}

\subsubsection*{\texttt{generate\_users\_with\_class}}
- Simulates user generation.

\paragraph{Arguments}
\begin{itemize}
    \item \texttt{list\_size}: number of users to generate.
    \item \texttt{interested\_friend\_simulation\_size}: fixed number of users each user is interested in.
    \item \texttt{seed}: seed for random generation.
\end{itemize}

If two users are mutually interested (i.e., both appear in each other's \texttt{interested\_friend} list), they are added to each other's \texttt{social\_current} list. Returns\texttt{list[User]} – a list of generated User objects.

\subsubsection*{\texttt{add\_fixed\_users}}
- Adds predefined users (e.g., project creators) to the user list. This function mutates the list passed in.

\subsubsection*{\texttt{add\_user}}
- Interactive function that prompts for user input (like a registration form) and appends a new \texttt{User} object to the user list.

<<<<<<< Updated upstream
<<<<<<< Updated upstream
\\
Question 4:
	• We use a tree structure to match users based on their preferred attributes. Attributes are ranked as decision nodes according to user priorities (e.g., if a user values hobbies the most, hobbies will be the first level of the tree). Users who meet a given attribute are assigned a 1, while those who do not are assigned a 0. As a result, different users follow different branches, and a recommendation list is generated by prioritizing those who fulfill the highest number of a user's preferred attributes.
\\
We build the preference tree using the \texttt{data\_wrangling} function by converting users' information and the matching status of their attributes into a CSV file named \texttt{data.csv}. We first call the \texttt{add\_priority} function to allow users to order their characteristics by preference, storing the result in a list called \texttt{heading}. Then, we filter the dataset to create a \texttt{potential\_users} list, containing only those users whose dating goals match that of the current user. In order to build the CSV file, we initialize a dictionary with keys corresponding to the column headers in the file. By default, the dictionary contains a \texttt{name} key, to which we add the names of the users from \texttt{potential\_users}. The other keys in the dictionary correspond to each attribute in \texttt{heading}, and their values are either 1 (indicating a match) or 0 (indicating no match), based on comparing the attribute value of each potential user with those of the current user. Lastly, a pandas \texttt{DataFrame} is created from the dictionary and exported to the CSV file.
\\
\\
\texttt{run\_preference\_tree} is a recursive function that returns a list of ranked recommended users by traversing the binary tree in the preference-based manner, which prioritizes the left subtree first (closest match) before processing the right subtree (lower match). The base case occurs when \texttt{self.\_root} is a list, which stores user names (indicating a leaf node). The function is then able to extend the \texttt{recommendation\_list} with the user names, returns, and stops recursion. The recursive step happens when the current node is not a leaf. The function extends the \texttt{recommendation\_list} by recursively traversing the left subtree first (higher preference) then the right subtree (lower preference).
\\
\\
=======
\\ 
>>>>>>> Stashed changes
=======
\\ 
>>>>>>> Stashed changes


\paragraph{Instructions for running the program}
Sample demonstration: Run main.py. The app with the UI should then pop up. Enter any name, say, 'Peter' to continue. Then fill in the form to complete a registration. Choose "Meeting new friends" for the Dating Goal. This tells the system that you are looking for friends more than looking for relationships. Rank the features you value the most using at the bottom of the page. Click "Create Profile".

Then click "Find Matches". Here, you can either choose Match or Pass. After you are done matching, press Exit. You will be re-directed back to the main menu.

Now, you can create another profile for another person, say, 'Mary'. But this time, for "Dating Goal", choose the three options other than "Meeting New Friends", for example, "Long-term relationship". Click "Create Profile". Instead of matching friends, you will be brought to a page that helps you match with someone who is also looking for a relationship. After you successfully match a romantic partner, you can press "Return to Home".

Then, this time input "admin" as the name. This would log you into the admin console. For debugging purposes, you can "Print User List to Console". Press "View Network Graph" to view the visualization of the connections of the users in the application. Supposedly, a local web application would pop up in your default browser.

There are two connection maps: Social connections (friends) and Romantic connections (relationships). You can navigate the maps freely to see the connections between users. Try out the searching function by inputting "Peter" in the search box. If a user is found, it will locate that user node in the graph and highlighting his/her connection with red. The function also shows how many connections that person has.



<<<<<<< Updated upstream
=======

>>>>>>> Stashed changes
\paragraph{Changes to the project plan}
(tree part): Initially, we implemented the tree using the basic <self._root> and <self._subtree> structure to align with the format of Exercise 2's animal tree. However, we found that using a binary tree with self._root, self._left, and self._right was more suitable for our recommendation system. This approach is particularly effective because all the 1s in the tree, representing users most relevant to the target user, are positioned along the leftmost branch. By using a binary tree, we can simplify the process of generating a recommendation list by recursively traversing only the leftmost branch.


\paragraph{Discussion}
The graph effectively visualizes connections between users through edges, allowing us, as editors, to review potential relationships. Additionally, the tree structure sets priorities at different levels, enabling the creation of a customized tree and a corresponding recommendation list. This successfully fulfills our goal of developing a connection-based application.

\section*{References}

Plotly. (2025). \textit{Plotly}.
\url{https://plotly.com/python/}
\\
University of Toronto. (2024). \textit{Quick facts}.
\url{https://www.utoronto.ca/about-u-of-t/quick-facts}


% NOTE: LaTeX does have a built-in way of generating references automatically,
% but it's a bit tricky to use so we STRONGLY recommend writing your references
% manually, using a standard academic format like APA or MLA.
% (E.g., https://owl.purdue.edu/owl/research_and_citation/apa_style/apa_formatting_and_style_guide/general_format.html)

\end{document}
